#!/bin/bash

if [ "$BASH_SOURCE" = "$0" ]; then
    echo "This script can only be sourced."
    exit 1
fi

# If not running interactively, don't do anything
[[ $- != *i* ]] && return

##
## GENERAL OPTIONS 
##

# Prevent file overwrite on stdout redirection
# Use `>|` to force redirection to an existing file
set -o noclobber

# Update window size after every command
shopt -s checkwinsize

# Enable history expansion with space
# E.g. typing !!<space> will replace the !! with your last command
bind Space:magic-space

# Turn on recursive globbing (enables ** to recurse all directories)
shopt -s globstar 2> /dev/null

##
## HISTORY OPTIONS 
##

# Don't put duplicate lines or lines starting with space in the history.
HISTCONTROL="erasedups:ignoreboth"

# Don't record some commands
export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear"

# Useful timestamp format
HISTTIMEFORMAT='%F %T '

# Huge history. Doesn't appear to slow things down, so why not?
HISTSIZE=500000
HISTFILESIZE=100000

# Append to the history file, don't overwrite it
shopt -s histappend

# Save multi-line commands as one command
shopt -s cmdhist

# Enable incremental history search with up/down arrows (also Readline goodness)
# Learn more about this here: http://codeinthehole.com/writing/the-most-important-command-line-tip-incremental-history-searching-with-inputrc/
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'
bind '"\e[C": forward-char'
bind '"\e[D": backward-char'

##
## TAB-COMPLETION (Readline bindings) 
##

# Display matches for ambiguous patterns at first tab press
bind "set show-all-if-ambiguous on"

##
## DIRECTORY NAVIGATION 
##

# Prepend cd to directory names automatically
shopt -s autocd 2> /dev/null

# Correct spelling errors during tab-completion
shopt -s dirspell 2> /dev/null

# Correct spelling errors in arguments supplied to cd
shopt -s cdspell 2> /dev/null

# This defines where cd looks for targets
# Add the directories you want to have fast access to, separated by colon
# Ex: CDPATH=".:~:~/projects" will look for targets in the current working directory, in home and in the ~/projects folder
CDPATH="."

# This allows you to bookmark your favorite places across the file system
# Define a variable containing a path and you will be able to cd into it regardless of the directory you're in
shopt -s cdable_vars

# Source .env files upon entering a directory
function source_env {
  if [ -f "$PWD/.env" ]; then
    source $PWD/.env
  fi
}

function cd { 
  builtin cd "$@" && source_env
}

function pushd { 
  builtin pushd "$@" && source_env
}

function popd { 
  builtin popd "$@" && source_env
}

# This function returns a string intended to be used in the prompt label. It reflects the status of the current directory if it's a git managed directory. 
function prompt_text {
    local git=$(which git)
    if [ -n "$git" ]; then
        status=$(git status --porcelain -b 2> /dev/null | awk '{ if ($1 == "##") { if (gsub(/\.\.\..*/,"",$2)) up = "^"; branch = $2 }; if ($1 ~ "[MDA]") mod = "*"  } END { printf "%s%s%s", branch, mod, up }')
        if [ -n "$status" ]; then
            echo "($status) "
            return
        fi
    fi
}

# Returns a string intended for the shell title. Either the value of the TITLE variable or the current directory.
function title_text {
    if [ -n "$TITLE" ]; then
        echo $TITLE
    else 
        echo $(basename $PWD)
    fi
}

# Automatically trim long paths in the prompt (requires Bash 4.x)
export PROMPT_DIRTRIM=2

# Set the title and command prompts
case $TERM in
    screen)
        export PROMPT_COMMAND='echo -ne "\033k$(title_text)\033\\"'
        ;;
    *)
        hostname=`hostname -s`
        export PROMPT_COMMAND='echo -ne "\033]0;[${hostname:0:7}] $(title_text)\007"'
        ;;
esac

if [ -f ~/.ansi_colors ]; then
  source ~/.ansi_colors
else
  echo "Cannot find ~/.ansi_colors"
fi

# echo -e "testing \033[38;5;196;48;5;21mCOLOR1\033[38;5;208;48;5;159mCOLOR2\033[m"

# Primary prompt
PS1='\['$f_wht_i'\]\D{%H:%M:%S} \['$reset'\]\['$f_mag_b'\][\w]\['$reset'\] \['$f_grn_b'\]$(prompt_text)\['$reset'\]'
# Prompt for incomplete input (like when you forget closing quotes)
PS2='\['$f_wht_i'\]\D{%H:%M:%S} \['$reset'\]\['$f_blk'\]\['$b_blk'\][\w] $(prompt_text)\['$reset'\]'
# Prompt for 'select' command
#PS3=
# Prompt for execution traces (default '+' sign)
#PS4=

# Make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

# colored man pages
# mb - Start blinking
# md - Start bold mode
# me - End all mode like so, us, mb, md and mr
# so - Start standout mode
# se - End standout mode
# us - Start underlining
# ue - End underlining
man() {
    env \
        LESS_TERMCAP_mb=$(printf "$f_red") \
        LESS_TERMCAP_md=$(printf "$f_cyn_b") \
        LESS_TERMCAP_us=$(printf "$f_grn_i") \
        LESS_TERMCAP_so=$(printf "$b_red$f_ylw") \
        LESS_TERMCAP_me=$(printf "$reset") \
        LESS_TERMCAP_se=$(printf "$reset") \
        LESS_TERMCAP_ue=$(printf "$reset") \
        man "$@"
}

# Set up path
export PATH=/usr/bin:/usr/sbin:/bin:/sbin:$PATH	
case $(uname -s) in
	Linux)
		# Set additional path elements
		;;

	Darwin)
		CLICOLOR=1
		export LSCOLORS=Exfxcxdxbxegedabagacad

		# Enable bash completion for homebrew
		if [ -n "$(which brew)" ]; then
		    export PATH=/usr/local/bin:/usr/local/sbin:$PATH
            if [ -f $(brew --prefix)/etc/bash_completion ]; then
			    . $(brew --prefix)/etc/bash_completion
            fi
		fi
		;;
esac

# Load aliases
if [ -e ~/.bash_alias ]; then
	. ~/.bash_alias
fi

# Add scripts directory to path
if [ -d ~/envy/bin ]; then
    export PATH=$PATH:~/envy/bin
fi

# Add current directory to path
export PATH=$PATH:.

# Set JDK 
if [ -e ~/.jdk ]; then
	export JAVA_HOME=$(head -n 1 ~/.jdk | sed 's/.*\:[ \t]*//')
fi

# Set go
export PATH=$PATH:/usr/local/opt/go/libexec/bin

if [ -n "$(which aws)" ]; then
	export AWS_ACCESS_KEY_ID="$(aws configure get aws_access_key_id)"
	export AWS_SECRET_ACCESS_KEY="$(aws configure get aws_secret_access_key)"
fi

if [ -f ~/.credentials ]; then
  source ~/.credentials
fi

# Local env 
if [ -e ~/.bash_local ]; then
	. ~/.bash_local
fi

